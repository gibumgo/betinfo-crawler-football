# BaseRepository와 CsvRepository 비교 정리

본 문서는 기존 `BaseRepository`와 리팩토링 이후 도입한 `CsvRepository`의 역할과 내부 구현 차이를 정리한 기록이다.
기능 추가보다는 **구조와 책임 분리 관점에서 어떤 변화가 있었는지**를 중심으로 비교한다.

---

## 1. 전반적인 차이

| 구분     | BaseRepository               | CsvRepository               |
| :----- | :--------------------------- | :-------------------------- |
| 역할     | 단순 CSV 저장                    | CSV 생성, 이어쓰기, 중복 제거 등 저장 전반 |
| 상태 관리  | 생성 시 `column_map`을 받아 상태로 보관 | 별도의 상태 없이 호출 시 인자로 전달       |
| 데이터 처리 | 호출부에서 dict 변환 필요             | 내부에서 타입을 확인해 변환             |
| 확장 방식  | 기능 추가 시 하위 클래스 영향            | 세부 메서드 단위로 확장 가능            |

기존 BaseRepository는 CSV 파일에 데이터를 저장하는 최소한의 역할을 수행하는 구조였다.
저장 방식은 덮어쓰기로 고정되어 있었고, 컬럼 매핑 정보 역시 객체 생성 시점에 주입되어 이후에는 변경할 수 없는 상태였다. 이로 인해 저장 방식이나 데이터 구조가 바뀌는 경우, 이를 사용하는 리포지토리 전반에 영향을 주기 쉬운 구조였다.

반면 CsvRepository는 CSV 저장 전반을 담당하는 범용 저장소로 설계되었다.
파일 생성, 이어쓰기, 중복 제거와 같은 세부 기능을 선택적으로 사용할 수 있도록 분리했고, 저장에 필요한 정보는 객체 상태로 보관하지 않고 메서드 호출 시 전달하도록 변경했다. 이를 통해 저장 로직 자체는 상태에 의존하지 않게 되었다.

---

## 2. BaseRepository 정리

BaseRepository는 CSV 저장 로직을 공통화하기 위한 목적으로 도입되었다.
데이터 매핑과 파일 저장 과정이 하나의 메서드에 포함되어 있으며, 기본적인 사용에는 문제가 없었지만 구조가 단순한 만큼 확장에는 제약이 있었다.

객체를 생성할 때 column_map을 반드시 전달해야 했고, 이 값은 인스턴스의 상태로 유지되었다.
저장 시에는 입력된 데이터 리스트를 순회하며 매핑을 적용한 뒤 DataFrame을 생성하고, 기존 파일을 덮어쓰는 방식으로 CSV를 생성했다.

입력 데이터의 타입에 대한 처리는 고려되어 있지 않아, Pydantic 모델이나 Dataclass를 사용하는 경우 호출부에서 미리 딕셔너리로 변환해야 했다.

### 클래스 구조

```python
class BaseRepository:
    def __init__(self, column_map: dict):
        self.column_map = column_map

    def save_to_csv(self, items: list, filename: str) -> None:
        ...
```

### 구조적 특징 요약

| 항목    | 내용                        |
| ----- | ------------------------- |
| 상태 보유 | `column_map`을 인스턴스 변수로 보관 |
| 책임 범위 | 데이터 매핑 + CSV 저장           |
| 저장 전략 | 덮어쓰기 고정                   |
| 타입 처리 | 호출부에서 사전 변환 필요            |

### 처리 흐름

1. 객체 생성 시 컬럼 매핑 정보 저장
2. 입력 데이터 리스트 순회
3. `column_map` 기준으로 key 매핑
4. DataFrame 생성
5. CSV 파일 덮어쓰기 저장

---

## 3. CsvRepository 정리

CsvRepository는 저장 로직을 하나의 기술적 책임으로 분리하는 방향으로 설계되었다.
데이터의 도메인 의미를 알 필요 없이 입력된 데이터를 CSV로 저장하는 과정 자체에만 집중한다.

### 클래스 구조

```python
class CsvRepository:
    def save_to_csv(
        self,
        items,
        filename,
        append=False,
        deduplicate=False,
        column_map=None
    ):
        ...
    
    def _prepare_dataframe(self, ...): ...
    def _convert_item_to_dict(self, ...): ...
    def _ensure_directory(self, ...): ...
    def _save_append(self, ...): ...
    def _save_overwrite(self, ...): ...
```

### 내부 역할 분리

| 메서드                     | 역할                               |
| ----------------------- | -------------------------------- |
| `save_to_csv`           | 저장 과정 전체를 조율하는 진입점               |
| `_prepare_dataframe`    | 입력 데이터를 DataFrame으로 변환           |
| `_convert_item_to_dict` | 데이터 타입(Pydantic, Dataclass 등) 판별 |
| `_ensure_directory`     | 저장 경로 확인 및 디렉터리 생성               |
| `_save_append`          | 기존 파일 병합 및 중복 제거                 |
| `_save_overwrite`       | 신규 생성 또는 덮어쓰기                    |

### 처리 흐름

이를 위해 내부 로직을 여러 단계의 메서드로 나누었다.
입력 데이터는 먼저 DataFrame으로 변환되며 이 과정에서 Pydantic, Dataclass, dict 여부를 내부에서 판단한다. 필요할 경우 컬럼 매핑도 이 단계에서 선택적으로 적용된다.

저장 단계에서는 파일 경로를 확인하고, 디렉터리가 없으면 자동으로 생성한다.
이후 설정된 옵션에 따라 기존 파일에 데이터를 이어쓰거나 새 파일로 덮어쓰는 방식 중 하나를 선택한다.
이어쓰기의 경우에는 기존 데이터와 병합한 뒤 필요하다면 중복 제거도 수행한다.

---

## 4. 로직 관점 비교

| 항목      | BaseRepository | CsvRepository  |
| :------ | :------------- | :------------- |
| 타입 처리   | 호출부 책임         | 내부에서 자동 처리     |
| 저장 방식   | 덮어쓰기 고정        | 이어쓰기 / 덮어쓰기 선택 |
| 디렉터리 처리 | 없음             | 자동 생성          |
| 컬럼 매핑   | 생성 시 고정        | 호출 시 선택        |

---

## 5. 리포지토리 사용 구조 변화

리팩토링 이후 도메인 리포지토리는 저장 방식의 세부 구현을 알 필요가 없게 되었다.

### 예시 구조

```text
[Domain Repository]
    └─ MatchRepository
         └─ save(...)
              └─ CsvRepository.save_to_csv(...)
```

도메인 리포지토리는 어떤 데이터를 어떤 파일에 저장할지만 정의하고
구체적인 저장 방식은 `CsvRepository`에 위임한다.

---

## 6. 정리

기존 구조에서는 데이터 타입 변환과 저장 방식 선택이 호출부의 책임에 가까웠다.
CsvRepository로 전환한 이후에는 이러한 판단을 저장소 내부에서 처리하게 되었고, 호출부에서는 저장 구현을 거의 의식하지 않아도 되었다.

또한 디렉터리 생성, CSV 저장 방식 분기와 같은 반복 로직이 한 곳으로 모이면서,
저장 관련 코드의 흐름을 따라가기가 한결 수월해졌다.

이번 변경은 CSV 저장 기능을 확장하기 위한 작업이라기보다는
저장과 관련된 책임을 명확히 분리하기 위한 구조 정리에 가까웠다.

그 결과 저장 방식과 관련된 수정 범위가 줄어들었고
도메인 코드와 저장 기술 간의 의존성도 이전보다 느슨해졌다.
이 문서는 해당 구조 변경 과정과 판단을 기록해 두기 위한 참고 자료로 남긴다.

* CsvRepository ↔ DB Repository 인터페이스 비교
* CSV 기반 Upsert 전략 정리
* 도메인 Repository 최소 책임 규칙 문서화
